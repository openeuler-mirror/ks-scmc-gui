// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: image_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_image_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_image_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "image_types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_image_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_image_5fservice_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_image_5fservice_2eproto;
namespace image {
class CheckReply;
class CheckReplyDefaultTypeInternal;
extern CheckReplyDefaultTypeInternal _CheckReply_default_instance_;
class CheckRequest;
class CheckRequestDefaultTypeInternal;
extern CheckRequestDefaultTypeInternal _CheckRequest_default_instance_;
class DownloadReply;
class DownloadReplyDefaultTypeInternal;
extern DownloadReplyDefaultTypeInternal _DownloadReply_default_instance_;
class DownloadRequest;
class DownloadRequestDefaultTypeInternal;
extern DownloadRequestDefaultTypeInternal _DownloadRequest_default_instance_;
class ListDBReply;
class ListDBReplyDefaultTypeInternal;
extern ListDBReplyDefaultTypeInternal _ListDBReply_default_instance_;
class ListDBRequest;
class ListDBRequestDefaultTypeInternal;
extern ListDBRequestDefaultTypeInternal _ListDBRequest_default_instance_;
class ListReply;
class ListReplyDefaultTypeInternal;
extern ListReplyDefaultTypeInternal _ListReply_default_instance_;
class ListRequest;
class ListRequestDefaultTypeInternal;
extern ListRequestDefaultTypeInternal _ListRequest_default_instance_;
class RemoveReply;
class RemoveReplyDefaultTypeInternal;
extern RemoveReplyDefaultTypeInternal _RemoveReply_default_instance_;
class RemoveRequest;
class RemoveRequestDefaultTypeInternal;
extern RemoveRequestDefaultTypeInternal _RemoveRequest_default_instance_;
class UpdateReply;
class UpdateReplyDefaultTypeInternal;
extern UpdateReplyDefaultTypeInternal _UpdateReply_default_instance_;
class UpdateRequest;
class UpdateRequestDefaultTypeInternal;
extern UpdateRequestDefaultTypeInternal _UpdateRequest_default_instance_;
class UploadReply;
class UploadReplyDefaultTypeInternal;
extern UploadReplyDefaultTypeInternal _UploadReply_default_instance_;
class UploadRequest;
class UploadRequestDefaultTypeInternal;
extern UploadRequestDefaultTypeInternal _UploadRequest_default_instance_;
}  // namespace image
PROTOBUF_NAMESPACE_OPEN
template<> ::image::CheckReply* Arena::CreateMaybeMessage<::image::CheckReply>(Arena*);
template<> ::image::CheckRequest* Arena::CreateMaybeMessage<::image::CheckRequest>(Arena*);
template<> ::image::DownloadReply* Arena::CreateMaybeMessage<::image::DownloadReply>(Arena*);
template<> ::image::DownloadRequest* Arena::CreateMaybeMessage<::image::DownloadRequest>(Arena*);
template<> ::image::ListDBReply* Arena::CreateMaybeMessage<::image::ListDBReply>(Arena*);
template<> ::image::ListDBRequest* Arena::CreateMaybeMessage<::image::ListDBRequest>(Arena*);
template<> ::image::ListReply* Arena::CreateMaybeMessage<::image::ListReply>(Arena*);
template<> ::image::ListRequest* Arena::CreateMaybeMessage<::image::ListRequest>(Arena*);
template<> ::image::RemoveReply* Arena::CreateMaybeMessage<::image::RemoveReply>(Arena*);
template<> ::image::RemoveRequest* Arena::CreateMaybeMessage<::image::RemoveRequest>(Arena*);
template<> ::image::UpdateReply* Arena::CreateMaybeMessage<::image::UpdateReply>(Arena*);
template<> ::image::UpdateRequest* Arena::CreateMaybeMessage<::image::UpdateRequest>(Arena*);
template<> ::image::UploadReply* Arena::CreateMaybeMessage<::image::UploadReply>(Arena*);
template<> ::image::UploadRequest* Arena::CreateMaybeMessage<::image::UploadRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace image {

// ===================================================================

class ListRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.ListRequest) */ {
 public:
  inline ListRequest() : ListRequest(nullptr) {};
  virtual ~ListRequest();

  ListRequest(const ListRequest& from);
  ListRequest(ListRequest&& from) noexcept
    : ListRequest() {
    *this = ::std::move(from);
  }

  inline ListRequest& operator=(const ListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRequest& operator=(ListRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListRequest* internal_default_instance() {
    return reinterpret_cast<const ListRequest*>(
               &_ListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ListRequest& a, ListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListRequest* New() const final {
    return CreateMaybeMessage<ListRequest>(nullptr);
  }

  ListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListRequest& from);
  void MergeFrom(const ListRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.ListRequest";
  }
  protected:
  explicit ListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kNodeIdFieldNumber = 2,
  };
  // .common.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::RequestHeader& header() const;
  ::common::RequestHeader* release_header();
  ::common::RequestHeader* mutable_header();
  void set_allocated_header(::common::RequestHeader* header);
  private:
  const ::common::RequestHeader& _internal_header() const;
  ::common::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::RequestHeader* header);
  ::common::RequestHeader* unsafe_arena_release_header();

  // int64 node_id = 2;
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int64 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:image.ListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::RequestHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::int64 node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.ListReply) */ {
 public:
  inline ListReply() : ListReply(nullptr) {};
  virtual ~ListReply();

  ListReply(const ListReply& from);
  ListReply(ListReply&& from) noexcept
    : ListReply() {
    *this = ::std::move(from);
  }

  inline ListReply& operator=(const ListReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListReply& operator=(ListReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListReply* internal_default_instance() {
    return reinterpret_cast<const ListReply*>(
               &_ListReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListReply& a, ListReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ListReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListReply* New() const final {
    return CreateMaybeMessage<ListReply>(nullptr);
  }

  ListReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListReply& from);
  void MergeFrom(const ListReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.ListReply";
  }
  protected:
  explicit ListReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImagesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .image.ImageInfo images = 2;
  int images_size() const;
  private:
  int _internal_images_size() const;
  public:
  void clear_images();
  ::image::ImageInfo* mutable_images(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::image::ImageInfo >*
      mutable_images();
  private:
  const ::image::ImageInfo& _internal_images(int index) const;
  ::image::ImageInfo* _internal_add_images();
  public:
  const ::image::ImageInfo& images(int index) const;
  ::image::ImageInfo* add_images();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::image::ImageInfo >&
      images() const;

  // .common.ReplyHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::ReplyHeader& header() const;
  ::common::ReplyHeader* release_header();
  ::common::ReplyHeader* mutable_header();
  void set_allocated_header(::common::ReplyHeader* header);
  private:
  const ::common::ReplyHeader& _internal_header() const;
  ::common::ReplyHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::ReplyHeader* header);
  ::common::ReplyHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:image.ListReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::image::ImageInfo > images_;
  ::common::ReplyHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListDBRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.ListDBRequest) */ {
 public:
  inline ListDBRequest() : ListDBRequest(nullptr) {};
  virtual ~ListDBRequest();

  ListDBRequest(const ListDBRequest& from);
  ListDBRequest(ListDBRequest&& from) noexcept
    : ListDBRequest() {
    *this = ::std::move(from);
  }

  inline ListDBRequest& operator=(const ListDBRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDBRequest& operator=(ListDBRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListDBRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListDBRequest* internal_default_instance() {
    return reinterpret_cast<const ListDBRequest*>(
               &_ListDBRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ListDBRequest& a, ListDBRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDBRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDBRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListDBRequest* New() const final {
    return CreateMaybeMessage<ListDBRequest>(nullptr);
  }

  ListDBRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListDBRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListDBRequest& from);
  void MergeFrom(const ListDBRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDBRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.ListDBRequest";
  }
  protected:
  explicit ListDBRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .common.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::RequestHeader& header() const;
  ::common::RequestHeader* release_header();
  ::common::RequestHeader* mutable_header();
  void set_allocated_header(::common::RequestHeader* header);
  private:
  const ::common::RequestHeader& _internal_header() const;
  ::common::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::RequestHeader* header);
  ::common::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:image.ListDBRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ListDBReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.ListDBReply) */ {
 public:
  inline ListDBReply() : ListDBReply(nullptr) {};
  virtual ~ListDBReply();

  ListDBReply(const ListDBReply& from);
  ListDBReply(ListDBReply&& from) noexcept
    : ListDBReply() {
    *this = ::std::move(from);
  }

  inline ListDBReply& operator=(const ListDBReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDBReply& operator=(ListDBReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListDBReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListDBReply* internal_default_instance() {
    return reinterpret_cast<const ListDBReply*>(
               &_ListDBReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ListDBReply& a, ListDBReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDBReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDBReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListDBReply* New() const final {
    return CreateMaybeMessage<ListDBReply>(nullptr);
  }

  ListDBReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListDBReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListDBReply& from);
  void MergeFrom(const ListDBReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDBReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.ListDBReply";
  }
  protected:
  explicit ListDBReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImagesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .image.ImageDBInfo images = 2;
  int images_size() const;
  private:
  int _internal_images_size() const;
  public:
  void clear_images();
  ::image::ImageDBInfo* mutable_images(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::image::ImageDBInfo >*
      mutable_images();
  private:
  const ::image::ImageDBInfo& _internal_images(int index) const;
  ::image::ImageDBInfo* _internal_add_images();
  public:
  const ::image::ImageDBInfo& images(int index) const;
  ::image::ImageDBInfo* add_images();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::image::ImageDBInfo >&
      images() const;

  // .common.ReplyHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::ReplyHeader& header() const;
  ::common::ReplyHeader* release_header();
  ::common::ReplyHeader* mutable_header();
  void set_allocated_header(::common::ReplyHeader* header);
  private:
  const ::common::ReplyHeader& _internal_header() const;
  ::common::ReplyHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::ReplyHeader* header);
  ::common::ReplyHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:image.ListDBReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::image::ImageDBInfo > images_;
  ::common::ReplyHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UploadRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.UploadRequest) */ {
 public:
  inline UploadRequest() : UploadRequest(nullptr) {};
  virtual ~UploadRequest();

  UploadRequest(const UploadRequest& from);
  UploadRequest(UploadRequest&& from) noexcept
    : UploadRequest() {
    *this = ::std::move(from);
  }

  inline UploadRequest& operator=(const UploadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadRequest& operator=(UploadRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UploadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UploadRequest* internal_default_instance() {
    return reinterpret_cast<const UploadRequest*>(
               &_UploadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UploadRequest& a, UploadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UploadRequest* New() const final {
    return CreateMaybeMessage<UploadRequest>(nullptr);
  }

  UploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UploadRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UploadRequest& from);
  void MergeFrom(const UploadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.UploadRequest";
  }
  protected:
  explicit UploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkDataFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // bytes chunk_data = 3;
  void clear_chunk_data();
  const std::string& chunk_data() const;
  void set_chunk_data(const std::string& value);
  void set_chunk_data(std::string&& value);
  void set_chunk_data(const char* value);
  void set_chunk_data(const void* value, size_t size);
  std::string* mutable_chunk_data();
  std::string* release_chunk_data();
  void set_allocated_chunk_data(std::string* chunk_data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_chunk_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_chunk_data(
      std::string* chunk_data);
  private:
  const std::string& _internal_chunk_data() const;
  void _internal_set_chunk_data(const std::string& value);
  std::string* _internal_mutable_chunk_data();
  public:

  // .common.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::RequestHeader& header() const;
  ::common::RequestHeader* release_header();
  ::common::RequestHeader* mutable_header();
  void set_allocated_header(::common::RequestHeader* header);
  private:
  const ::common::RequestHeader& _internal_header() const;
  ::common::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::RequestHeader* header);
  ::common::RequestHeader* unsafe_arena_release_header();

  // .image.UploadInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::image::UploadInfo& info() const;
  ::image::UploadInfo* release_info();
  ::image::UploadInfo* mutable_info();
  void set_allocated_info(::image::UploadInfo* info);
  private:
  const ::image::UploadInfo& _internal_info() const;
  ::image::UploadInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::image::UploadInfo* info);
  ::image::UploadInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:image.UploadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_data_;
  ::common::RequestHeader* header_;
  ::image::UploadInfo* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UploadReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.UploadReply) */ {
 public:
  inline UploadReply() : UploadReply(nullptr) {};
  virtual ~UploadReply();

  UploadReply(const UploadReply& from);
  UploadReply(UploadReply&& from) noexcept
    : UploadReply() {
    *this = ::std::move(from);
  }

  inline UploadReply& operator=(const UploadReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadReply& operator=(UploadReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UploadReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UploadReply* internal_default_instance() {
    return reinterpret_cast<const UploadReply*>(
               &_UploadReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UploadReply& a, UploadReply& b) {
    a.Swap(&b);
  }
  inline void Swap(UploadReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UploadReply* New() const final {
    return CreateMaybeMessage<UploadReply>(nullptr);
  }

  UploadReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UploadReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UploadReply& from);
  void MergeFrom(const UploadReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UploadReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.UploadReply";
  }
  protected:
  explicit UploadReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kImageIdFieldNumber = 2,
  };
  // .common.ReplyHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::ReplyHeader& header() const;
  ::common::ReplyHeader* release_header();
  ::common::ReplyHeader* mutable_header();
  void set_allocated_header(::common::ReplyHeader* header);
  private:
  const ::common::ReplyHeader& _internal_header() const;
  ::common::ReplyHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::ReplyHeader* header);
  ::common::ReplyHeader* unsafe_arena_release_header();

  // int64 image_id = 2;
  void clear_image_id();
  ::PROTOBUF_NAMESPACE_ID::int64 image_id() const;
  void set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_image_id() const;
  void _internal_set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:image.UploadReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::ReplyHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::int64 image_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdateRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.UpdateRequest) */ {
 public:
  inline UpdateRequest() : UpdateRequest(nullptr) {};
  virtual ~UpdateRequest();

  UpdateRequest(const UpdateRequest& from);
  UpdateRequest(UpdateRequest&& from) noexcept
    : UpdateRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRequest& operator=(const UpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRequest& operator=(UpdateRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRequest*>(
               &_UpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateRequest& a, UpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateRequest* New() const final {
    return CreateMaybeMessage<UpdateRequest>(nullptr);
  }

  UpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateRequest& from);
  void MergeFrom(const UpdateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.UpdateRequest";
  }
  protected:
  explicit UpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkDataFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kInfoFieldNumber = 3,
    kImageIdFieldNumber = 2,
  };
  // bytes chunk_data = 4;
  void clear_chunk_data();
  const std::string& chunk_data() const;
  void set_chunk_data(const std::string& value);
  void set_chunk_data(std::string&& value);
  void set_chunk_data(const char* value);
  void set_chunk_data(const void* value, size_t size);
  std::string* mutable_chunk_data();
  std::string* release_chunk_data();
  void set_allocated_chunk_data(std::string* chunk_data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_chunk_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_chunk_data(
      std::string* chunk_data);
  private:
  const std::string& _internal_chunk_data() const;
  void _internal_set_chunk_data(const std::string& value);
  std::string* _internal_mutable_chunk_data();
  public:

  // .common.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::RequestHeader& header() const;
  ::common::RequestHeader* release_header();
  ::common::RequestHeader* mutable_header();
  void set_allocated_header(::common::RequestHeader* header);
  private:
  const ::common::RequestHeader& _internal_header() const;
  ::common::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::RequestHeader* header);
  ::common::RequestHeader* unsafe_arena_release_header();

  // .image.UploadInfo info = 3;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::image::UploadInfo& info() const;
  ::image::UploadInfo* release_info();
  ::image::UploadInfo* mutable_info();
  void set_allocated_info(::image::UploadInfo* info);
  private:
  const ::image::UploadInfo& _internal_info() const;
  ::image::UploadInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::image::UploadInfo* info);
  ::image::UploadInfo* unsafe_arena_release_info();

  // int64 image_id = 2;
  void clear_image_id();
  ::PROTOBUF_NAMESPACE_ID::int64 image_id() const;
  void set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_image_id() const;
  void _internal_set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:image.UpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_data_;
  ::common::RequestHeader* header_;
  ::image::UploadInfo* info_;
  ::PROTOBUF_NAMESPACE_ID::int64 image_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdateReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.UpdateReply) */ {
 public:
  inline UpdateReply() : UpdateReply(nullptr) {};
  virtual ~UpdateReply();

  UpdateReply(const UpdateReply& from);
  UpdateReply(UpdateReply&& from) noexcept
    : UpdateReply() {
    *this = ::std::move(from);
  }

  inline UpdateReply& operator=(const UpdateReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateReply& operator=(UpdateReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateReply* internal_default_instance() {
    return reinterpret_cast<const UpdateReply*>(
               &_UpdateReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdateReply& a, UpdateReply& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateReply* New() const final {
    return CreateMaybeMessage<UpdateReply>(nullptr);
  }

  UpdateReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateReply& from);
  void MergeFrom(const UpdateReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.UpdateReply";
  }
  protected:
  explicit UpdateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .common.ReplyHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::ReplyHeader& header() const;
  ::common::ReplyHeader* release_header();
  ::common::ReplyHeader* mutable_header();
  void set_allocated_header(::common::ReplyHeader* header);
  private:
  const ::common::ReplyHeader& _internal_header() const;
  ::common::ReplyHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::ReplyHeader* header);
  ::common::ReplyHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:image.UpdateReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::ReplyHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DownloadRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.DownloadRequest) */ {
 public:
  inline DownloadRequest() : DownloadRequest(nullptr) {};
  virtual ~DownloadRequest();

  DownloadRequest(const DownloadRequest& from);
  DownloadRequest(DownloadRequest&& from) noexcept
    : DownloadRequest() {
    *this = ::std::move(from);
  }

  inline DownloadRequest& operator=(const DownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadRequest& operator=(DownloadRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DownloadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadRequest*>(
               &_DownloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DownloadRequest& a, DownloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DownloadRequest* New() const final {
    return CreateMaybeMessage<DownloadRequest>(nullptr);
  }

  DownloadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DownloadRequest& from);
  void MergeFrom(const DownloadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.DownloadRequest";
  }
  protected:
  explicit DownloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kImageIdFieldNumber = 2,
  };
  // .common.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::RequestHeader& header() const;
  ::common::RequestHeader* release_header();
  ::common::RequestHeader* mutable_header();
  void set_allocated_header(::common::RequestHeader* header);
  private:
  const ::common::RequestHeader& _internal_header() const;
  ::common::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::RequestHeader* header);
  ::common::RequestHeader* unsafe_arena_release_header();

  // int64 image_id = 2;
  void clear_image_id();
  ::PROTOBUF_NAMESPACE_ID::int64 image_id() const;
  void set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_image_id() const;
  void _internal_set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:image.DownloadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::RequestHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::int64 image_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DownloadReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.DownloadReply) */ {
 public:
  inline DownloadReply() : DownloadReply(nullptr) {};
  virtual ~DownloadReply();

  DownloadReply(const DownloadReply& from);
  DownloadReply(DownloadReply&& from) noexcept
    : DownloadReply() {
    *this = ::std::move(from);
  }

  inline DownloadReply& operator=(const DownloadReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadReply& operator=(DownloadReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DownloadReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DownloadReply* internal_default_instance() {
    return reinterpret_cast<const DownloadReply*>(
               &_DownloadReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DownloadReply& a, DownloadReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DownloadReply* New() const final {
    return CreateMaybeMessage<DownloadReply>(nullptr);
  }

  DownloadReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DownloadReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DownloadReply& from);
  void MergeFrom(const DownloadReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.DownloadReply";
  }
  protected:
  explicit DownloadReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkDataFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // bytes chunk_data = 3;
  void clear_chunk_data();
  const std::string& chunk_data() const;
  void set_chunk_data(const std::string& value);
  void set_chunk_data(std::string&& value);
  void set_chunk_data(const char* value);
  void set_chunk_data(const void* value, size_t size);
  std::string* mutable_chunk_data();
  std::string* release_chunk_data();
  void set_allocated_chunk_data(std::string* chunk_data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_chunk_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_chunk_data(
      std::string* chunk_data);
  private:
  const std::string& _internal_chunk_data() const;
  void _internal_set_chunk_data(const std::string& value);
  std::string* _internal_mutable_chunk_data();
  public:

  // .common.ReplyHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::ReplyHeader& header() const;
  ::common::ReplyHeader* release_header();
  ::common::ReplyHeader* mutable_header();
  void set_allocated_header(::common::ReplyHeader* header);
  private:
  const ::common::ReplyHeader& _internal_header() const;
  ::common::ReplyHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::ReplyHeader* header);
  ::common::ReplyHeader* unsafe_arena_release_header();

  // .image.UploadInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::image::UploadInfo& info() const;
  ::image::UploadInfo* release_info();
  ::image::UploadInfo* mutable_info();
  void set_allocated_info(::image::UploadInfo* info);
  private:
  const ::image::UploadInfo& _internal_info() const;
  ::image::UploadInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::image::UploadInfo* info);
  ::image::UploadInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:image.DownloadReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_data_;
  ::common::ReplyHeader* header_;
  ::image::UploadInfo* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CheckRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.CheckRequest) */ {
 public:
  inline CheckRequest() : CheckRequest(nullptr) {};
  virtual ~CheckRequest();

  CheckRequest(const CheckRequest& from);
  CheckRequest(CheckRequest&& from) noexcept
    : CheckRequest() {
    *this = ::std::move(from);
  }

  inline CheckRequest& operator=(const CheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckRequest& operator=(CheckRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckRequest* internal_default_instance() {
    return reinterpret_cast<const CheckRequest*>(
               &_CheckRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CheckRequest& a, CheckRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckRequest* New() const final {
    return CreateMaybeMessage<CheckRequest>(nullptr);
  }

  CheckRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckRequest& from);
  void MergeFrom(const CheckRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.CheckRequest";
  }
  protected:
  explicit CheckRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRejectReasonFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kImageIdFieldNumber = 2,
    kCheckStatusFieldNumber = 3,
  };
  // string reject_reason = 4;
  void clear_reject_reason();
  const std::string& reject_reason() const;
  void set_reject_reason(const std::string& value);
  void set_reject_reason(std::string&& value);
  void set_reject_reason(const char* value);
  void set_reject_reason(const char* value, size_t size);
  std::string* mutable_reject_reason();
  std::string* release_reject_reason();
  void set_allocated_reject_reason(std::string* reject_reason);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_reject_reason();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_reject_reason(
      std::string* reject_reason);
  private:
  const std::string& _internal_reject_reason() const;
  void _internal_set_reject_reason(const std::string& value);
  std::string* _internal_mutable_reject_reason();
  public:

  // .common.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::RequestHeader& header() const;
  ::common::RequestHeader* release_header();
  ::common::RequestHeader* mutable_header();
  void set_allocated_header(::common::RequestHeader* header);
  private:
  const ::common::RequestHeader& _internal_header() const;
  ::common::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::RequestHeader* header);
  ::common::RequestHeader* unsafe_arena_release_header();

  // int64 image_id = 2;
  void clear_image_id();
  ::PROTOBUF_NAMESPACE_ID::int64 image_id() const;
  void set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_image_id() const;
  void _internal_set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool check_status = 3;
  void clear_check_status();
  bool check_status() const;
  void set_check_status(bool value);
  private:
  bool _internal_check_status() const;
  void _internal_set_check_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:image.CheckRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reject_reason_;
  ::common::RequestHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::int64 image_id_;
  bool check_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CheckReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.CheckReply) */ {
 public:
  inline CheckReply() : CheckReply(nullptr) {};
  virtual ~CheckReply();

  CheckReply(const CheckReply& from);
  CheckReply(CheckReply&& from) noexcept
    : CheckReply() {
    *this = ::std::move(from);
  }

  inline CheckReply& operator=(const CheckReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckReply& operator=(CheckReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckReply* internal_default_instance() {
    return reinterpret_cast<const CheckReply*>(
               &_CheckReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CheckReply& a, CheckReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckReply* New() const final {
    return CreateMaybeMessage<CheckReply>(nullptr);
  }

  CheckReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckReply& from);
  void MergeFrom(const CheckReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.CheckReply";
  }
  protected:
  explicit CheckReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .common.ReplyHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::ReplyHeader& header() const;
  ::common::ReplyHeader* release_header();
  ::common::ReplyHeader* mutable_header();
  void set_allocated_header(::common::ReplyHeader* header);
  private:
  const ::common::ReplyHeader& _internal_header() const;
  ::common::ReplyHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::ReplyHeader* header);
  ::common::ReplyHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:image.CheckReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::ReplyHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RemoveRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.RemoveRequest) */ {
 public:
  inline RemoveRequest() : RemoveRequest(nullptr) {};
  virtual ~RemoveRequest();

  RemoveRequest(const RemoveRequest& from);
  RemoveRequest(RemoveRequest&& from) noexcept
    : RemoveRequest() {
    *this = ::std::move(from);
  }

  inline RemoveRequest& operator=(const RemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveRequest& operator=(RemoveRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveRequest*>(
               &_RemoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RemoveRequest& a, RemoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoveRequest* New() const final {
    return CreateMaybeMessage<RemoveRequest>(nullptr);
  }

  RemoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoveRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoveRequest& from);
  void MergeFrom(const RemoveRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.RemoveRequest";
  }
  protected:
  explicit RemoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageIdsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated int64 image_ids = 2;
  int image_ids_size() const;
  private:
  int _internal_image_ids_size() const;
  public:
  void clear_image_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_image_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_image_ids() const;
  void _internal_add_image_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_image_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 image_ids(int index) const;
  void set_image_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_image_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      image_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_image_ids();

  // .common.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::RequestHeader& header() const;
  ::common::RequestHeader* release_header();
  ::common::RequestHeader* mutable_header();
  void set_allocated_header(::common::RequestHeader* header);
  private:
  const ::common::RequestHeader& _internal_header() const;
  ::common::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::RequestHeader* header);
  ::common::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:image.RemoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > image_ids_;
  mutable std::atomic<int> _image_ids_cached_byte_size_;
  ::common::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// -------------------------------------------------------------------

class RemoveReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:image.RemoveReply) */ {
 public:
  inline RemoveReply() : RemoveReply(nullptr) {};
  virtual ~RemoveReply();

  RemoveReply(const RemoveReply& from);
  RemoveReply(RemoveReply&& from) noexcept
    : RemoveReply() {
    *this = ::std::move(from);
  }

  inline RemoveReply& operator=(const RemoveReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveReply& operator=(RemoveReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemoveReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveReply* internal_default_instance() {
    return reinterpret_cast<const RemoveReply*>(
               &_RemoveReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RemoveReply& a, RemoveReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoveReply* New() const final {
    return CreateMaybeMessage<RemoveReply>(nullptr);
  }

  RemoveReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoveReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemoveReply& from);
  void MergeFrom(const RemoveReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "image.RemoveReply";
  }
  protected:
  explicit RemoveReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_image_5fservice_2eproto);
    return ::descriptor_table_image_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkIdsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated string ok_ids = 2;
  int ok_ids_size() const;
  private:
  int _internal_ok_ids_size() const;
  public:
  void clear_ok_ids();
  const std::string& ok_ids(int index) const;
  std::string* mutable_ok_ids(int index);
  void set_ok_ids(int index, const std::string& value);
  void set_ok_ids(int index, std::string&& value);
  void set_ok_ids(int index, const char* value);
  void set_ok_ids(int index, const char* value, size_t size);
  std::string* add_ok_ids();
  void add_ok_ids(const std::string& value);
  void add_ok_ids(std::string&& value);
  void add_ok_ids(const char* value);
  void add_ok_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ok_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ok_ids();
  private:
  const std::string& _internal_ok_ids(int index) const;
  std::string* _internal_add_ok_ids();
  public:

  // .common.ReplyHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::ReplyHeader& header() const;
  ::common::ReplyHeader* release_header();
  ::common::ReplyHeader* mutable_header();
  void set_allocated_header(::common::ReplyHeader* header);
  private:
  const ::common::ReplyHeader& _internal_header() const;
  ::common::ReplyHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::ReplyHeader* header);
  ::common::ReplyHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:image.RemoveReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ok_ids_;
  ::common::ReplyHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_image_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ListRequest

// .common.RequestHeader header = 1;
inline bool ListRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListRequest::has_header() const {
  return _internal_has_header();
}
inline const ::common::RequestHeader& ListRequest::_internal_header() const {
  const ::common::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::RequestHeader*>(
      &::common::_RequestHeader_default_instance_);
}
inline const ::common::RequestHeader& ListRequest::header() const {
  // @@protoc_insertion_point(field_get:image.ListRequest.header)
  return _internal_header();
}
inline void ListRequest::unsafe_arena_set_allocated_header(
    ::common::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.ListRequest.header)
}
inline ::common::RequestHeader* ListRequest::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::RequestHeader* ListRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.ListRequest.header)
  
  ::common::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::RequestHeader* ListRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::RequestHeader* ListRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.ListRequest.header)
  return _internal_mutable_header();
}
inline void ListRequest::set_allocated_header(::common::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.ListRequest.header)
}

// int64 node_id = 2;
inline void ListRequest::clear_node_id() {
  node_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ListRequest::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ListRequest::node_id() const {
  // @@protoc_insertion_point(field_get:image.ListRequest.node_id)
  return _internal_node_id();
}
inline void ListRequest::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  node_id_ = value;
}
inline void ListRequest::set_node_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:image.ListRequest.node_id)
}

// -------------------------------------------------------------------

// ListReply

// .common.ReplyHeader header = 1;
inline bool ListReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListReply::has_header() const {
  return _internal_has_header();
}
inline const ::common::ReplyHeader& ListReply::_internal_header() const {
  const ::common::ReplyHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::ReplyHeader*>(
      &::common::_ReplyHeader_default_instance_);
}
inline const ::common::ReplyHeader& ListReply::header() const {
  // @@protoc_insertion_point(field_get:image.ListReply.header)
  return _internal_header();
}
inline void ListReply::unsafe_arena_set_allocated_header(
    ::common::ReplyHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.ListReply.header)
}
inline ::common::ReplyHeader* ListReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::ReplyHeader* ListReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.ListReply.header)
  
  ::common::ReplyHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::ReplyHeader* ListReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ReplyHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::ReplyHeader* ListReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.ListReply.header)
  return _internal_mutable_header();
}
inline void ListReply::set_allocated_header(::common::ReplyHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.ListReply.header)
}

// repeated .image.ImageInfo images = 2;
inline int ListReply::_internal_images_size() const {
  return images_.size();
}
inline int ListReply::images_size() const {
  return _internal_images_size();
}
inline ::image::ImageInfo* ListReply::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:image.ListReply.images)
  return images_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::image::ImageInfo >*
ListReply::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:image.ListReply.images)
  return &images_;
}
inline const ::image::ImageInfo& ListReply::_internal_images(int index) const {
  return images_.Get(index);
}
inline const ::image::ImageInfo& ListReply::images(int index) const {
  // @@protoc_insertion_point(field_get:image.ListReply.images)
  return _internal_images(index);
}
inline ::image::ImageInfo* ListReply::_internal_add_images() {
  return images_.Add();
}
inline ::image::ImageInfo* ListReply::add_images() {
  // @@protoc_insertion_point(field_add:image.ListReply.images)
  return _internal_add_images();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::image::ImageInfo >&
ListReply::images() const {
  // @@protoc_insertion_point(field_list:image.ListReply.images)
  return images_;
}

// -------------------------------------------------------------------

// ListDBRequest

// .common.RequestHeader header = 1;
inline bool ListDBRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListDBRequest::has_header() const {
  return _internal_has_header();
}
inline const ::common::RequestHeader& ListDBRequest::_internal_header() const {
  const ::common::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::RequestHeader*>(
      &::common::_RequestHeader_default_instance_);
}
inline const ::common::RequestHeader& ListDBRequest::header() const {
  // @@protoc_insertion_point(field_get:image.ListDBRequest.header)
  return _internal_header();
}
inline void ListDBRequest::unsafe_arena_set_allocated_header(
    ::common::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.ListDBRequest.header)
}
inline ::common::RequestHeader* ListDBRequest::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::RequestHeader* ListDBRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.ListDBRequest.header)
  
  ::common::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::RequestHeader* ListDBRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::RequestHeader* ListDBRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.ListDBRequest.header)
  return _internal_mutable_header();
}
inline void ListDBRequest::set_allocated_header(::common::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.ListDBRequest.header)
}

// -------------------------------------------------------------------

// ListDBReply

// .common.ReplyHeader header = 1;
inline bool ListDBReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ListDBReply::has_header() const {
  return _internal_has_header();
}
inline const ::common::ReplyHeader& ListDBReply::_internal_header() const {
  const ::common::ReplyHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::ReplyHeader*>(
      &::common::_ReplyHeader_default_instance_);
}
inline const ::common::ReplyHeader& ListDBReply::header() const {
  // @@protoc_insertion_point(field_get:image.ListDBReply.header)
  return _internal_header();
}
inline void ListDBReply::unsafe_arena_set_allocated_header(
    ::common::ReplyHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.ListDBReply.header)
}
inline ::common::ReplyHeader* ListDBReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::ReplyHeader* ListDBReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.ListDBReply.header)
  
  ::common::ReplyHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::ReplyHeader* ListDBReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ReplyHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::ReplyHeader* ListDBReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.ListDBReply.header)
  return _internal_mutable_header();
}
inline void ListDBReply::set_allocated_header(::common::ReplyHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.ListDBReply.header)
}

// repeated .image.ImageDBInfo images = 2;
inline int ListDBReply::_internal_images_size() const {
  return images_.size();
}
inline int ListDBReply::images_size() const {
  return _internal_images_size();
}
inline ::image::ImageDBInfo* ListDBReply::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:image.ListDBReply.images)
  return images_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::image::ImageDBInfo >*
ListDBReply::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:image.ListDBReply.images)
  return &images_;
}
inline const ::image::ImageDBInfo& ListDBReply::_internal_images(int index) const {
  return images_.Get(index);
}
inline const ::image::ImageDBInfo& ListDBReply::images(int index) const {
  // @@protoc_insertion_point(field_get:image.ListDBReply.images)
  return _internal_images(index);
}
inline ::image::ImageDBInfo* ListDBReply::_internal_add_images() {
  return images_.Add();
}
inline ::image::ImageDBInfo* ListDBReply::add_images() {
  // @@protoc_insertion_point(field_add:image.ListDBReply.images)
  return _internal_add_images();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::image::ImageDBInfo >&
ListDBReply::images() const {
  // @@protoc_insertion_point(field_list:image.ListDBReply.images)
  return images_;
}

// -------------------------------------------------------------------

// UploadRequest

// .common.RequestHeader header = 1;
inline bool UploadRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool UploadRequest::has_header() const {
  return _internal_has_header();
}
inline const ::common::RequestHeader& UploadRequest::_internal_header() const {
  const ::common::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::RequestHeader*>(
      &::common::_RequestHeader_default_instance_);
}
inline const ::common::RequestHeader& UploadRequest::header() const {
  // @@protoc_insertion_point(field_get:image.UploadRequest.header)
  return _internal_header();
}
inline void UploadRequest::unsafe_arena_set_allocated_header(
    ::common::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.UploadRequest.header)
}
inline ::common::RequestHeader* UploadRequest::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::RequestHeader* UploadRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.UploadRequest.header)
  
  ::common::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::RequestHeader* UploadRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::RequestHeader* UploadRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.UploadRequest.header)
  return _internal_mutable_header();
}
inline void UploadRequest::set_allocated_header(::common::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.UploadRequest.header)
}

// .image.UploadInfo info = 2;
inline bool UploadRequest::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool UploadRequest::has_info() const {
  return _internal_has_info();
}
inline const ::image::UploadInfo& UploadRequest::_internal_info() const {
  const ::image::UploadInfo* p = info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::image::UploadInfo*>(
      &::image::_UploadInfo_default_instance_);
}
inline const ::image::UploadInfo& UploadRequest::info() const {
  // @@protoc_insertion_point(field_get:image.UploadRequest.info)
  return _internal_info();
}
inline void UploadRequest::unsafe_arena_set_allocated_info(
    ::image::UploadInfo* info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.UploadRequest.info)
}
inline ::image::UploadInfo* UploadRequest::release_info() {
  auto temp = unsafe_arena_release_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::image::UploadInfo* UploadRequest::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:image.UploadRequest.info)
  
  ::image::UploadInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::image::UploadInfo* UploadRequest::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::image::UploadInfo>(GetArena());
    info_ = p;
  }
  return info_;
}
inline ::image::UploadInfo* UploadRequest::mutable_info() {
  // @@protoc_insertion_point(field_mutable:image.UploadRequest.info)
  return _internal_mutable_info();
}
inline void UploadRequest::set_allocated_info(::image::UploadInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info)->GetArena();
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:image.UploadRequest.info)
}

// bytes chunk_data = 3;
inline void UploadRequest::clear_chunk_data() {
  chunk_data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UploadRequest::chunk_data() const {
  // @@protoc_insertion_point(field_get:image.UploadRequest.chunk_data)
  return _internal_chunk_data();
}
inline void UploadRequest::set_chunk_data(const std::string& value) {
  _internal_set_chunk_data(value);
  // @@protoc_insertion_point(field_set:image.UploadRequest.chunk_data)
}
inline std::string* UploadRequest::mutable_chunk_data() {
  // @@protoc_insertion_point(field_mutable:image.UploadRequest.chunk_data)
  return _internal_mutable_chunk_data();
}
inline const std::string& UploadRequest::_internal_chunk_data() const {
  return chunk_data_.Get();
}
inline void UploadRequest::_internal_set_chunk_data(const std::string& value) {
  
  chunk_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UploadRequest::set_chunk_data(std::string&& value) {
  
  chunk_data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:image.UploadRequest.chunk_data)
}
inline void UploadRequest::set_chunk_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chunk_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:image.UploadRequest.chunk_data)
}
inline void UploadRequest::set_chunk_data(const void* value,
    size_t size) {
  
  chunk_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:image.UploadRequest.chunk_data)
}
inline std::string* UploadRequest::_internal_mutable_chunk_data() {
  
  return chunk_data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UploadRequest::release_chunk_data() {
  // @@protoc_insertion_point(field_release:image.UploadRequest.chunk_data)
  return chunk_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UploadRequest::set_allocated_chunk_data(std::string* chunk_data) {
  if (chunk_data != nullptr) {
    
  } else {
    
  }
  chunk_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chunk_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:image.UploadRequest.chunk_data)
}
inline std::string* UploadRequest::unsafe_arena_release_chunk_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:image.UploadRequest.chunk_data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return chunk_data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UploadRequest::unsafe_arena_set_allocated_chunk_data(
    std::string* chunk_data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (chunk_data != nullptr) {
    
  } else {
    
  }
  chunk_data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      chunk_data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.UploadRequest.chunk_data)
}

// -------------------------------------------------------------------

// UploadReply

// .common.ReplyHeader header = 1;
inline bool UploadReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool UploadReply::has_header() const {
  return _internal_has_header();
}
inline const ::common::ReplyHeader& UploadReply::_internal_header() const {
  const ::common::ReplyHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::ReplyHeader*>(
      &::common::_ReplyHeader_default_instance_);
}
inline const ::common::ReplyHeader& UploadReply::header() const {
  // @@protoc_insertion_point(field_get:image.UploadReply.header)
  return _internal_header();
}
inline void UploadReply::unsafe_arena_set_allocated_header(
    ::common::ReplyHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.UploadReply.header)
}
inline ::common::ReplyHeader* UploadReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::ReplyHeader* UploadReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.UploadReply.header)
  
  ::common::ReplyHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::ReplyHeader* UploadReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ReplyHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::ReplyHeader* UploadReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.UploadReply.header)
  return _internal_mutable_header();
}
inline void UploadReply::set_allocated_header(::common::ReplyHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.UploadReply.header)
}

// int64 image_id = 2;
inline void UploadReply::clear_image_id() {
  image_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UploadReply::_internal_image_id() const {
  return image_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UploadReply::image_id() const {
  // @@protoc_insertion_point(field_get:image.UploadReply.image_id)
  return _internal_image_id();
}
inline void UploadReply::_internal_set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  image_id_ = value;
}
inline void UploadReply::set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_image_id(value);
  // @@protoc_insertion_point(field_set:image.UploadReply.image_id)
}

// -------------------------------------------------------------------

// UpdateRequest

// .common.RequestHeader header = 1;
inline bool UpdateRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool UpdateRequest::has_header() const {
  return _internal_has_header();
}
inline const ::common::RequestHeader& UpdateRequest::_internal_header() const {
  const ::common::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::RequestHeader*>(
      &::common::_RequestHeader_default_instance_);
}
inline const ::common::RequestHeader& UpdateRequest::header() const {
  // @@protoc_insertion_point(field_get:image.UpdateRequest.header)
  return _internal_header();
}
inline void UpdateRequest::unsafe_arena_set_allocated_header(
    ::common::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.UpdateRequest.header)
}
inline ::common::RequestHeader* UpdateRequest::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::RequestHeader* UpdateRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.UpdateRequest.header)
  
  ::common::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::RequestHeader* UpdateRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::RequestHeader* UpdateRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.UpdateRequest.header)
  return _internal_mutable_header();
}
inline void UpdateRequest::set_allocated_header(::common::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.UpdateRequest.header)
}

// int64 image_id = 2;
inline void UpdateRequest::clear_image_id() {
  image_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UpdateRequest::_internal_image_id() const {
  return image_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UpdateRequest::image_id() const {
  // @@protoc_insertion_point(field_get:image.UpdateRequest.image_id)
  return _internal_image_id();
}
inline void UpdateRequest::_internal_set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  image_id_ = value;
}
inline void UpdateRequest::set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_image_id(value);
  // @@protoc_insertion_point(field_set:image.UpdateRequest.image_id)
}

// .image.UploadInfo info = 3;
inline bool UpdateRequest::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool UpdateRequest::has_info() const {
  return _internal_has_info();
}
inline const ::image::UploadInfo& UpdateRequest::_internal_info() const {
  const ::image::UploadInfo* p = info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::image::UploadInfo*>(
      &::image::_UploadInfo_default_instance_);
}
inline const ::image::UploadInfo& UpdateRequest::info() const {
  // @@protoc_insertion_point(field_get:image.UpdateRequest.info)
  return _internal_info();
}
inline void UpdateRequest::unsafe_arena_set_allocated_info(
    ::image::UploadInfo* info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.UpdateRequest.info)
}
inline ::image::UploadInfo* UpdateRequest::release_info() {
  auto temp = unsafe_arena_release_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::image::UploadInfo* UpdateRequest::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:image.UpdateRequest.info)
  
  ::image::UploadInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::image::UploadInfo* UpdateRequest::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::image::UploadInfo>(GetArena());
    info_ = p;
  }
  return info_;
}
inline ::image::UploadInfo* UpdateRequest::mutable_info() {
  // @@protoc_insertion_point(field_mutable:image.UpdateRequest.info)
  return _internal_mutable_info();
}
inline void UpdateRequest::set_allocated_info(::image::UploadInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info)->GetArena();
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:image.UpdateRequest.info)
}

// bytes chunk_data = 4;
inline void UpdateRequest::clear_chunk_data() {
  chunk_data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UpdateRequest::chunk_data() const {
  // @@protoc_insertion_point(field_get:image.UpdateRequest.chunk_data)
  return _internal_chunk_data();
}
inline void UpdateRequest::set_chunk_data(const std::string& value) {
  _internal_set_chunk_data(value);
  // @@protoc_insertion_point(field_set:image.UpdateRequest.chunk_data)
}
inline std::string* UpdateRequest::mutable_chunk_data() {
  // @@protoc_insertion_point(field_mutable:image.UpdateRequest.chunk_data)
  return _internal_mutable_chunk_data();
}
inline const std::string& UpdateRequest::_internal_chunk_data() const {
  return chunk_data_.Get();
}
inline void UpdateRequest::_internal_set_chunk_data(const std::string& value) {
  
  chunk_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UpdateRequest::set_chunk_data(std::string&& value) {
  
  chunk_data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:image.UpdateRequest.chunk_data)
}
inline void UpdateRequest::set_chunk_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chunk_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:image.UpdateRequest.chunk_data)
}
inline void UpdateRequest::set_chunk_data(const void* value,
    size_t size) {
  
  chunk_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:image.UpdateRequest.chunk_data)
}
inline std::string* UpdateRequest::_internal_mutable_chunk_data() {
  
  return chunk_data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UpdateRequest::release_chunk_data() {
  // @@protoc_insertion_point(field_release:image.UpdateRequest.chunk_data)
  return chunk_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdateRequest::set_allocated_chunk_data(std::string* chunk_data) {
  if (chunk_data != nullptr) {
    
  } else {
    
  }
  chunk_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chunk_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:image.UpdateRequest.chunk_data)
}
inline std::string* UpdateRequest::unsafe_arena_release_chunk_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:image.UpdateRequest.chunk_data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return chunk_data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UpdateRequest::unsafe_arena_set_allocated_chunk_data(
    std::string* chunk_data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (chunk_data != nullptr) {
    
  } else {
    
  }
  chunk_data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      chunk_data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.UpdateRequest.chunk_data)
}

// -------------------------------------------------------------------

// UpdateReply

// .common.ReplyHeader header = 1;
inline bool UpdateReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool UpdateReply::has_header() const {
  return _internal_has_header();
}
inline const ::common::ReplyHeader& UpdateReply::_internal_header() const {
  const ::common::ReplyHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::ReplyHeader*>(
      &::common::_ReplyHeader_default_instance_);
}
inline const ::common::ReplyHeader& UpdateReply::header() const {
  // @@protoc_insertion_point(field_get:image.UpdateReply.header)
  return _internal_header();
}
inline void UpdateReply::unsafe_arena_set_allocated_header(
    ::common::ReplyHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.UpdateReply.header)
}
inline ::common::ReplyHeader* UpdateReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::ReplyHeader* UpdateReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.UpdateReply.header)
  
  ::common::ReplyHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::ReplyHeader* UpdateReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ReplyHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::ReplyHeader* UpdateReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.UpdateReply.header)
  return _internal_mutable_header();
}
inline void UpdateReply::set_allocated_header(::common::ReplyHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.UpdateReply.header)
}

// -------------------------------------------------------------------

// DownloadRequest

// .common.RequestHeader header = 1;
inline bool DownloadRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool DownloadRequest::has_header() const {
  return _internal_has_header();
}
inline const ::common::RequestHeader& DownloadRequest::_internal_header() const {
  const ::common::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::RequestHeader*>(
      &::common::_RequestHeader_default_instance_);
}
inline const ::common::RequestHeader& DownloadRequest::header() const {
  // @@protoc_insertion_point(field_get:image.DownloadRequest.header)
  return _internal_header();
}
inline void DownloadRequest::unsafe_arena_set_allocated_header(
    ::common::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.DownloadRequest.header)
}
inline ::common::RequestHeader* DownloadRequest::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::RequestHeader* DownloadRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.DownloadRequest.header)
  
  ::common::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::RequestHeader* DownloadRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::RequestHeader* DownloadRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.DownloadRequest.header)
  return _internal_mutable_header();
}
inline void DownloadRequest::set_allocated_header(::common::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.DownloadRequest.header)
}

// int64 image_id = 2;
inline void DownloadRequest::clear_image_id() {
  image_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DownloadRequest::_internal_image_id() const {
  return image_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DownloadRequest::image_id() const {
  // @@protoc_insertion_point(field_get:image.DownloadRequest.image_id)
  return _internal_image_id();
}
inline void DownloadRequest::_internal_set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  image_id_ = value;
}
inline void DownloadRequest::set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_image_id(value);
  // @@protoc_insertion_point(field_set:image.DownloadRequest.image_id)
}

// -------------------------------------------------------------------

// DownloadReply

// .common.ReplyHeader header = 1;
inline bool DownloadReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool DownloadReply::has_header() const {
  return _internal_has_header();
}
inline const ::common::ReplyHeader& DownloadReply::_internal_header() const {
  const ::common::ReplyHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::ReplyHeader*>(
      &::common::_ReplyHeader_default_instance_);
}
inline const ::common::ReplyHeader& DownloadReply::header() const {
  // @@protoc_insertion_point(field_get:image.DownloadReply.header)
  return _internal_header();
}
inline void DownloadReply::unsafe_arena_set_allocated_header(
    ::common::ReplyHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.DownloadReply.header)
}
inline ::common::ReplyHeader* DownloadReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::ReplyHeader* DownloadReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.DownloadReply.header)
  
  ::common::ReplyHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::ReplyHeader* DownloadReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ReplyHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::ReplyHeader* DownloadReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.DownloadReply.header)
  return _internal_mutable_header();
}
inline void DownloadReply::set_allocated_header(::common::ReplyHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.DownloadReply.header)
}

// .image.UploadInfo info = 2;
inline bool DownloadReply::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool DownloadReply::has_info() const {
  return _internal_has_info();
}
inline const ::image::UploadInfo& DownloadReply::_internal_info() const {
  const ::image::UploadInfo* p = info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::image::UploadInfo*>(
      &::image::_UploadInfo_default_instance_);
}
inline const ::image::UploadInfo& DownloadReply::info() const {
  // @@protoc_insertion_point(field_get:image.DownloadReply.info)
  return _internal_info();
}
inline void DownloadReply::unsafe_arena_set_allocated_info(
    ::image::UploadInfo* info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.DownloadReply.info)
}
inline ::image::UploadInfo* DownloadReply::release_info() {
  auto temp = unsafe_arena_release_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::image::UploadInfo* DownloadReply::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:image.DownloadReply.info)
  
  ::image::UploadInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::image::UploadInfo* DownloadReply::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::image::UploadInfo>(GetArena());
    info_ = p;
  }
  return info_;
}
inline ::image::UploadInfo* DownloadReply::mutable_info() {
  // @@protoc_insertion_point(field_mutable:image.DownloadReply.info)
  return _internal_mutable_info();
}
inline void DownloadReply::set_allocated_info(::image::UploadInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info)->GetArena();
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:image.DownloadReply.info)
}

// bytes chunk_data = 3;
inline void DownloadReply::clear_chunk_data() {
  chunk_data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DownloadReply::chunk_data() const {
  // @@protoc_insertion_point(field_get:image.DownloadReply.chunk_data)
  return _internal_chunk_data();
}
inline void DownloadReply::set_chunk_data(const std::string& value) {
  _internal_set_chunk_data(value);
  // @@protoc_insertion_point(field_set:image.DownloadReply.chunk_data)
}
inline std::string* DownloadReply::mutable_chunk_data() {
  // @@protoc_insertion_point(field_mutable:image.DownloadReply.chunk_data)
  return _internal_mutable_chunk_data();
}
inline const std::string& DownloadReply::_internal_chunk_data() const {
  return chunk_data_.Get();
}
inline void DownloadReply::_internal_set_chunk_data(const std::string& value) {
  
  chunk_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DownloadReply::set_chunk_data(std::string&& value) {
  
  chunk_data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:image.DownloadReply.chunk_data)
}
inline void DownloadReply::set_chunk_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chunk_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:image.DownloadReply.chunk_data)
}
inline void DownloadReply::set_chunk_data(const void* value,
    size_t size) {
  
  chunk_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:image.DownloadReply.chunk_data)
}
inline std::string* DownloadReply::_internal_mutable_chunk_data() {
  
  return chunk_data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DownloadReply::release_chunk_data() {
  // @@protoc_insertion_point(field_release:image.DownloadReply.chunk_data)
  return chunk_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DownloadReply::set_allocated_chunk_data(std::string* chunk_data) {
  if (chunk_data != nullptr) {
    
  } else {
    
  }
  chunk_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chunk_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:image.DownloadReply.chunk_data)
}
inline std::string* DownloadReply::unsafe_arena_release_chunk_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:image.DownloadReply.chunk_data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return chunk_data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DownloadReply::unsafe_arena_set_allocated_chunk_data(
    std::string* chunk_data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (chunk_data != nullptr) {
    
  } else {
    
  }
  chunk_data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      chunk_data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.DownloadReply.chunk_data)
}

// -------------------------------------------------------------------

// CheckRequest

// .common.RequestHeader header = 1;
inline bool CheckRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool CheckRequest::has_header() const {
  return _internal_has_header();
}
inline const ::common::RequestHeader& CheckRequest::_internal_header() const {
  const ::common::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::RequestHeader*>(
      &::common::_RequestHeader_default_instance_);
}
inline const ::common::RequestHeader& CheckRequest::header() const {
  // @@protoc_insertion_point(field_get:image.CheckRequest.header)
  return _internal_header();
}
inline void CheckRequest::unsafe_arena_set_allocated_header(
    ::common::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.CheckRequest.header)
}
inline ::common::RequestHeader* CheckRequest::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::RequestHeader* CheckRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.CheckRequest.header)
  
  ::common::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::RequestHeader* CheckRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::RequestHeader* CheckRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.CheckRequest.header)
  return _internal_mutable_header();
}
inline void CheckRequest::set_allocated_header(::common::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.CheckRequest.header)
}

// int64 image_id = 2;
inline void CheckRequest::clear_image_id() {
  image_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CheckRequest::_internal_image_id() const {
  return image_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CheckRequest::image_id() const {
  // @@protoc_insertion_point(field_get:image.CheckRequest.image_id)
  return _internal_image_id();
}
inline void CheckRequest::_internal_set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  image_id_ = value;
}
inline void CheckRequest::set_image_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_image_id(value);
  // @@protoc_insertion_point(field_set:image.CheckRequest.image_id)
}

// bool check_status = 3;
inline void CheckRequest::clear_check_status() {
  check_status_ = false;
}
inline bool CheckRequest::_internal_check_status() const {
  return check_status_;
}
inline bool CheckRequest::check_status() const {
  // @@protoc_insertion_point(field_get:image.CheckRequest.check_status)
  return _internal_check_status();
}
inline void CheckRequest::_internal_set_check_status(bool value) {
  
  check_status_ = value;
}
inline void CheckRequest::set_check_status(bool value) {
  _internal_set_check_status(value);
  // @@protoc_insertion_point(field_set:image.CheckRequest.check_status)
}

// string reject_reason = 4;
inline void CheckRequest::clear_reject_reason() {
  reject_reason_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CheckRequest::reject_reason() const {
  // @@protoc_insertion_point(field_get:image.CheckRequest.reject_reason)
  return _internal_reject_reason();
}
inline void CheckRequest::set_reject_reason(const std::string& value) {
  _internal_set_reject_reason(value);
  // @@protoc_insertion_point(field_set:image.CheckRequest.reject_reason)
}
inline std::string* CheckRequest::mutable_reject_reason() {
  // @@protoc_insertion_point(field_mutable:image.CheckRequest.reject_reason)
  return _internal_mutable_reject_reason();
}
inline const std::string& CheckRequest::_internal_reject_reason() const {
  return reject_reason_.Get();
}
inline void CheckRequest::_internal_set_reject_reason(const std::string& value) {
  
  reject_reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CheckRequest::set_reject_reason(std::string&& value) {
  
  reject_reason_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:image.CheckRequest.reject_reason)
}
inline void CheckRequest::set_reject_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  reject_reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:image.CheckRequest.reject_reason)
}
inline void CheckRequest::set_reject_reason(const char* value,
    size_t size) {
  
  reject_reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:image.CheckRequest.reject_reason)
}
inline std::string* CheckRequest::_internal_mutable_reject_reason() {
  
  return reject_reason_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CheckRequest::release_reject_reason() {
  // @@protoc_insertion_point(field_release:image.CheckRequest.reject_reason)
  return reject_reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CheckRequest::set_allocated_reject_reason(std::string* reject_reason) {
  if (reject_reason != nullptr) {
    
  } else {
    
  }
  reject_reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reject_reason,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:image.CheckRequest.reject_reason)
}
inline std::string* CheckRequest::unsafe_arena_release_reject_reason() {
  // @@protoc_insertion_point(field_unsafe_arena_release:image.CheckRequest.reject_reason)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return reject_reason_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CheckRequest::unsafe_arena_set_allocated_reject_reason(
    std::string* reject_reason) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (reject_reason != nullptr) {
    
  } else {
    
  }
  reject_reason_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      reject_reason, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.CheckRequest.reject_reason)
}

// -------------------------------------------------------------------

// CheckReply

// .common.ReplyHeader header = 1;
inline bool CheckReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool CheckReply::has_header() const {
  return _internal_has_header();
}
inline const ::common::ReplyHeader& CheckReply::_internal_header() const {
  const ::common::ReplyHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::ReplyHeader*>(
      &::common::_ReplyHeader_default_instance_);
}
inline const ::common::ReplyHeader& CheckReply::header() const {
  // @@protoc_insertion_point(field_get:image.CheckReply.header)
  return _internal_header();
}
inline void CheckReply::unsafe_arena_set_allocated_header(
    ::common::ReplyHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.CheckReply.header)
}
inline ::common::ReplyHeader* CheckReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::ReplyHeader* CheckReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.CheckReply.header)
  
  ::common::ReplyHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::ReplyHeader* CheckReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ReplyHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::ReplyHeader* CheckReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.CheckReply.header)
  return _internal_mutable_header();
}
inline void CheckReply::set_allocated_header(::common::ReplyHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.CheckReply.header)
}

// -------------------------------------------------------------------

// RemoveRequest

// .common.RequestHeader header = 1;
inline bool RemoveRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RemoveRequest::has_header() const {
  return _internal_has_header();
}
inline const ::common::RequestHeader& RemoveRequest::_internal_header() const {
  const ::common::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::RequestHeader*>(
      &::common::_RequestHeader_default_instance_);
}
inline const ::common::RequestHeader& RemoveRequest::header() const {
  // @@protoc_insertion_point(field_get:image.RemoveRequest.header)
  return _internal_header();
}
inline void RemoveRequest::unsafe_arena_set_allocated_header(
    ::common::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.RemoveRequest.header)
}
inline ::common::RequestHeader* RemoveRequest::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::RequestHeader* RemoveRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.RemoveRequest.header)
  
  ::common::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::RequestHeader* RemoveRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::RequestHeader* RemoveRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.RemoveRequest.header)
  return _internal_mutable_header();
}
inline void RemoveRequest::set_allocated_header(::common::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.RemoveRequest.header)
}

// repeated int64 image_ids = 2;
inline int RemoveRequest::_internal_image_ids_size() const {
  return image_ids_.size();
}
inline int RemoveRequest::image_ids_size() const {
  return _internal_image_ids_size();
}
inline void RemoveRequest::clear_image_ids() {
  image_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoveRequest::_internal_image_ids(int index) const {
  return image_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoveRequest::image_ids(int index) const {
  // @@protoc_insertion_point(field_get:image.RemoveRequest.image_ids)
  return _internal_image_ids(index);
}
inline void RemoveRequest::set_image_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  image_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:image.RemoveRequest.image_ids)
}
inline void RemoveRequest::_internal_add_image_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  image_ids_.Add(value);
}
inline void RemoveRequest::add_image_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_image_ids(value);
  // @@protoc_insertion_point(field_add:image.RemoveRequest.image_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
RemoveRequest::_internal_image_ids() const {
  return image_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
RemoveRequest::image_ids() const {
  // @@protoc_insertion_point(field_list:image.RemoveRequest.image_ids)
  return _internal_image_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
RemoveRequest::_internal_mutable_image_ids() {
  return &image_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
RemoveRequest::mutable_image_ids() {
  // @@protoc_insertion_point(field_mutable_list:image.RemoveRequest.image_ids)
  return _internal_mutable_image_ids();
}

// -------------------------------------------------------------------

// RemoveReply

// .common.ReplyHeader header = 1;
inline bool RemoveReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RemoveReply::has_header() const {
  return _internal_has_header();
}
inline const ::common::ReplyHeader& RemoveReply::_internal_header() const {
  const ::common::ReplyHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::ReplyHeader*>(
      &::common::_ReplyHeader_default_instance_);
}
inline const ::common::ReplyHeader& RemoveReply::header() const {
  // @@protoc_insertion_point(field_get:image.RemoveReply.header)
  return _internal_header();
}
inline void RemoveReply::unsafe_arena_set_allocated_header(
    ::common::ReplyHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:image.RemoveReply.header)
}
inline ::common::ReplyHeader* RemoveReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::ReplyHeader* RemoveReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:image.RemoveReply.header)
  
  ::common::ReplyHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::ReplyHeader* RemoveReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ReplyHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::ReplyHeader* RemoveReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:image.RemoveReply.header)
  return _internal_mutable_header();
}
inline void RemoveReply::set_allocated_header(::common::ReplyHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:image.RemoveReply.header)
}

// repeated string ok_ids = 2;
inline int RemoveReply::_internal_ok_ids_size() const {
  return ok_ids_.size();
}
inline int RemoveReply::ok_ids_size() const {
  return _internal_ok_ids_size();
}
inline void RemoveReply::clear_ok_ids() {
  ok_ids_.Clear();
}
inline std::string* RemoveReply::add_ok_ids() {
  // @@protoc_insertion_point(field_add_mutable:image.RemoveReply.ok_ids)
  return _internal_add_ok_ids();
}
inline const std::string& RemoveReply::_internal_ok_ids(int index) const {
  return ok_ids_.Get(index);
}
inline const std::string& RemoveReply::ok_ids(int index) const {
  // @@protoc_insertion_point(field_get:image.RemoveReply.ok_ids)
  return _internal_ok_ids(index);
}
inline std::string* RemoveReply::mutable_ok_ids(int index) {
  // @@protoc_insertion_point(field_mutable:image.RemoveReply.ok_ids)
  return ok_ids_.Mutable(index);
}
inline void RemoveReply::set_ok_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:image.RemoveReply.ok_ids)
  ok_ids_.Mutable(index)->assign(value);
}
inline void RemoveReply::set_ok_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:image.RemoveReply.ok_ids)
  ok_ids_.Mutable(index)->assign(std::move(value));
}
inline void RemoveReply::set_ok_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ok_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:image.RemoveReply.ok_ids)
}
inline void RemoveReply::set_ok_ids(int index, const char* value, size_t size) {
  ok_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:image.RemoveReply.ok_ids)
}
inline std::string* RemoveReply::_internal_add_ok_ids() {
  return ok_ids_.Add();
}
inline void RemoveReply::add_ok_ids(const std::string& value) {
  ok_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:image.RemoveReply.ok_ids)
}
inline void RemoveReply::add_ok_ids(std::string&& value) {
  ok_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:image.RemoveReply.ok_ids)
}
inline void RemoveReply::add_ok_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ok_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:image.RemoveReply.ok_ids)
}
inline void RemoveReply::add_ok_ids(const char* value, size_t size) {
  ok_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:image.RemoveReply.ok_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RemoveReply::ok_ids() const {
  // @@protoc_insertion_point(field_list:image.RemoveReply.ok_ids)
  return ok_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RemoveReply::mutable_ok_ids() {
  // @@protoc_insertion_point(field_mutable_list:image.RemoveReply.ok_ids)
  return &ok_ids_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace image

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_image_5fservice_2eproto
