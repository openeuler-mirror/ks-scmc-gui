// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_user_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_user_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "user_types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_user_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_user_5fservice_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_user_5fservice_2eproto;
namespace user {
class LoginReply;
class LoginReplyDefaultTypeInternal;
extern LoginReplyDefaultTypeInternal _LoginReply_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LogoutReply;
class LogoutReplyDefaultTypeInternal;
extern LogoutReplyDefaultTypeInternal _LogoutReply_default_instance_;
class LogoutRequest;
class LogoutRequestDefaultTypeInternal;
extern LogoutRequestDefaultTypeInternal _LogoutRequest_default_instance_;
class SignupReply;
class SignupReplyDefaultTypeInternal;
extern SignupReplyDefaultTypeInternal _SignupReply_default_instance_;
class SignupRequest;
class SignupRequestDefaultTypeInternal;
extern SignupRequestDefaultTypeInternal _SignupRequest_default_instance_;
class UpdatePasswordReply;
class UpdatePasswordReplyDefaultTypeInternal;
extern UpdatePasswordReplyDefaultTypeInternal _UpdatePasswordReply_default_instance_;
class UpdatePasswordRequest;
class UpdatePasswordRequestDefaultTypeInternal;
extern UpdatePasswordRequestDefaultTypeInternal _UpdatePasswordRequest_default_instance_;
}  // namespace user
PROTOBUF_NAMESPACE_OPEN
template<> ::user::LoginReply* Arena::CreateMaybeMessage<::user::LoginReply>(Arena*);
template<> ::user::LoginRequest* Arena::CreateMaybeMessage<::user::LoginRequest>(Arena*);
template<> ::user::LogoutReply* Arena::CreateMaybeMessage<::user::LogoutReply>(Arena*);
template<> ::user::LogoutRequest* Arena::CreateMaybeMessage<::user::LogoutRequest>(Arena*);
template<> ::user::SignupReply* Arena::CreateMaybeMessage<::user::SignupReply>(Arena*);
template<> ::user::SignupRequest* Arena::CreateMaybeMessage<::user::SignupRequest>(Arena*);
template<> ::user::UpdatePasswordReply* Arena::CreateMaybeMessage<::user::UpdatePasswordReply>(Arena*);
template<> ::user::UpdatePasswordRequest* Arena::CreateMaybeMessage<::user::UpdatePasswordRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace user {

// ===================================================================

class SignupRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.SignupRequest) */ {
 public:
  inline SignupRequest() : SignupRequest(nullptr) {};
  virtual ~SignupRequest();

  SignupRequest(const SignupRequest& from);
  SignupRequest(SignupRequest&& from) noexcept
    : SignupRequest() {
    *this = ::std::move(from);
  }

  inline SignupRequest& operator=(const SignupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignupRequest& operator=(SignupRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignupRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignupRequest* internal_default_instance() {
    return reinterpret_cast<const SignupRequest*>(
               &_SignupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SignupRequest& a, SignupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignupRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignupRequest* New() const final {
    return CreateMaybeMessage<SignupRequest>(nullptr);
  }

  SignupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignupRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignupRequest& from);
  void MergeFrom(const SignupRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignupRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.SignupRequest";
  }
  protected:
  explicit SignupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_user_5fservice_2eproto);
    return ::descriptor_table_user_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kRoleFieldNumber = 4,
    kHeaderFieldNumber = 1,
  };
  // string username = 2;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_username();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_username(
      std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_password();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_password(
      std::string* password);
  private:
  const std::string& _internal_password() const;
  void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string role = 4;
  void clear_role();
  const std::string& role() const;
  void set_role(const std::string& value);
  void set_role(std::string&& value);
  void set_role(const char* value);
  void set_role(const char* value, size_t size);
  std::string* mutable_role();
  std::string* release_role();
  void set_allocated_role(std::string* role);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_role();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_role(
      std::string* role);
  private:
  const std::string& _internal_role() const;
  void _internal_set_role(const std::string& value);
  std::string* _internal_mutable_role();
  public:

  // .common.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::RequestHeader& header() const;
  ::common::RequestHeader* release_header();
  ::common::RequestHeader* mutable_header();
  void set_allocated_header(::common::RequestHeader* header);
  private:
  const ::common::RequestHeader& _internal_header() const;
  ::common::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::RequestHeader* header);
  ::common::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:user.SignupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr role_;
  ::common::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fservice_2eproto;
};
// -------------------------------------------------------------------

class SignupReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.SignupReply) */ {
 public:
  inline SignupReply() : SignupReply(nullptr) {};
  virtual ~SignupReply();

  SignupReply(const SignupReply& from);
  SignupReply(SignupReply&& from) noexcept
    : SignupReply() {
    *this = ::std::move(from);
  }

  inline SignupReply& operator=(const SignupReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignupReply& operator=(SignupReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignupReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignupReply* internal_default_instance() {
    return reinterpret_cast<const SignupReply*>(
               &_SignupReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SignupReply& a, SignupReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SignupReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignupReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignupReply* New() const final {
    return CreateMaybeMessage<SignupReply>(nullptr);
  }

  SignupReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignupReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignupReply& from);
  void MergeFrom(const SignupReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignupReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.SignupReply";
  }
  protected:
  explicit SignupReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_user_5fservice_2eproto);
    return ::descriptor_table_user_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .common.ReplyHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::ReplyHeader& header() const;
  ::common::ReplyHeader* release_header();
  ::common::ReplyHeader* mutable_header();
  void set_allocated_header(::common::ReplyHeader* header);
  private:
  const ::common::ReplyHeader& _internal_header() const;
  ::common::ReplyHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::ReplyHeader* header);
  ::common::ReplyHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:user.SignupReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::ReplyHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {};
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const final {
    return CreateMaybeMessage<LoginRequest>(nullptr);
  }

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_user_5fservice_2eproto);
    return ::descriptor_table_user_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // string username = 2;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_username();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_username(
      std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_password();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_password(
      std::string* password);
  private:
  const std::string& _internal_password() const;
  void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .common.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::RequestHeader& header() const;
  ::common::RequestHeader* release_header();
  ::common::RequestHeader* mutable_header();
  void set_allocated_header(::common::RequestHeader* header);
  private:
  const ::common::RequestHeader& _internal_header() const;
  ::common::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::RequestHeader* header);
  ::common::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:user.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::common::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LoginReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.LoginReply) */ {
 public:
  inline LoginReply() : LoginReply(nullptr) {};
  virtual ~LoginReply();

  LoginReply(const LoginReply& from);
  LoginReply(LoginReply&& from) noexcept
    : LoginReply() {
    *this = ::std::move(from);
  }

  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReply& operator=(LoginReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginReply* internal_default_instance() {
    return reinterpret_cast<const LoginReply*>(
               &_LoginReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginReply& a, LoginReply& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginReply* New() const final {
    return CreateMaybeMessage<LoginReply>(nullptr);
  }

  LoginReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginReply& from);
  void MergeFrom(const LoginReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.LoginReply";
  }
  protected:
  explicit LoginReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_user_5fservice_2eproto);
    return ::descriptor_table_user_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthKeyFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // string auth_key = 3;
  void clear_auth_key();
  const std::string& auth_key() const;
  void set_auth_key(const std::string& value);
  void set_auth_key(std::string&& value);
  void set_auth_key(const char* value);
  void set_auth_key(const char* value, size_t size);
  std::string* mutable_auth_key();
  std::string* release_auth_key();
  void set_allocated_auth_key(std::string* auth_key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_auth_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_auth_key(
      std::string* auth_key);
  private:
  const std::string& _internal_auth_key() const;
  void _internal_set_auth_key(const std::string& value);
  std::string* _internal_mutable_auth_key();
  public:

  // .common.ReplyHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::ReplyHeader& header() const;
  ::common::ReplyHeader* release_header();
  ::common::ReplyHeader* mutable_header();
  void set_allocated_header(::common::ReplyHeader* header);
  private:
  const ::common::ReplyHeader& _internal_header() const;
  ::common::ReplyHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::ReplyHeader* header);
  ::common::ReplyHeader* unsafe_arena_release_header();

  // int64 user_id = 2;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::int64 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:user.LoginReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_key_;
  ::common::ReplyHeader* header_;
  ::PROTOBUF_NAMESPACE_ID::int64 user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LogoutRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.LogoutRequest) */ {
 public:
  inline LogoutRequest() : LogoutRequest(nullptr) {};
  virtual ~LogoutRequest();

  LogoutRequest(const LogoutRequest& from);
  LogoutRequest(LogoutRequest&& from) noexcept
    : LogoutRequest() {
    *this = ::std::move(from);
  }

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutRequest& operator=(LogoutRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogoutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogoutRequest* internal_default_instance() {
    return reinterpret_cast<const LogoutRequest*>(
               &_LogoutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LogoutRequest& a, LogoutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogoutRequest* New() const final {
    return CreateMaybeMessage<LogoutRequest>(nullptr);
  }

  LogoutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogoutRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogoutRequest& from);
  void MergeFrom(const LogoutRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.LogoutRequest";
  }
  protected:
  explicit LogoutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_user_5fservice_2eproto);
    return ::descriptor_table_user_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .common.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::RequestHeader& header() const;
  ::common::RequestHeader* release_header();
  ::common::RequestHeader* mutable_header();
  void set_allocated_header(::common::RequestHeader* header);
  private:
  const ::common::RequestHeader& _internal_header() const;
  ::common::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::RequestHeader* header);
  ::common::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:user.LogoutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LogoutReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.LogoutReply) */ {
 public:
  inline LogoutReply() : LogoutReply(nullptr) {};
  virtual ~LogoutReply();

  LogoutReply(const LogoutReply& from);
  LogoutReply(LogoutReply&& from) noexcept
    : LogoutReply() {
    *this = ::std::move(from);
  }

  inline LogoutReply& operator=(const LogoutReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutReply& operator=(LogoutReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogoutReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogoutReply* internal_default_instance() {
    return reinterpret_cast<const LogoutReply*>(
               &_LogoutReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LogoutReply& a, LogoutReply& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogoutReply* New() const final {
    return CreateMaybeMessage<LogoutReply>(nullptr);
  }

  LogoutReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogoutReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogoutReply& from);
  void MergeFrom(const LogoutReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.LogoutReply";
  }
  protected:
  explicit LogoutReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_user_5fservice_2eproto);
    return ::descriptor_table_user_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
  };
  // .common.ReplyHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::ReplyHeader& header() const;
  ::common::ReplyHeader* release_header();
  ::common::ReplyHeader* mutable_header();
  void set_allocated_header(::common::ReplyHeader* header);
  private:
  const ::common::ReplyHeader& _internal_header() const;
  ::common::ReplyHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::ReplyHeader* header);
  ::common::ReplyHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:user.LogoutReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::ReplyHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdatePasswordRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.UpdatePasswordRequest) */ {
 public:
  inline UpdatePasswordRequest() : UpdatePasswordRequest(nullptr) {};
  virtual ~UpdatePasswordRequest();

  UpdatePasswordRequest(const UpdatePasswordRequest& from);
  UpdatePasswordRequest(UpdatePasswordRequest&& from) noexcept
    : UpdatePasswordRequest() {
    *this = ::std::move(from);
  }

  inline UpdatePasswordRequest& operator=(const UpdatePasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePasswordRequest& operator=(UpdatePasswordRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdatePasswordRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdatePasswordRequest* internal_default_instance() {
    return reinterpret_cast<const UpdatePasswordRequest*>(
               &_UpdatePasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdatePasswordRequest& a, UpdatePasswordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePasswordRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePasswordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePasswordRequest* New() const final {
    return CreateMaybeMessage<UpdatePasswordRequest>(nullptr);
  }

  UpdatePasswordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePasswordRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdatePasswordRequest& from);
  void MergeFrom(const UpdatePasswordRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePasswordRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.UpdatePasswordRequest";
  }
  protected:
  explicit UpdatePasswordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_user_5fservice_2eproto);
    return ::descriptor_table_user_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string password = 2;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_password();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_password(
      std::string* password);
  private:
  const std::string& _internal_password() const;
  void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .common.ReplyHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::ReplyHeader& header() const;
  ::common::ReplyHeader* release_header();
  ::common::ReplyHeader* mutable_header();
  void set_allocated_header(::common::ReplyHeader* header);
  private:
  const ::common::ReplyHeader& _internal_header() const;
  ::common::ReplyHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::ReplyHeader* header);
  ::common::ReplyHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:user.UpdatePasswordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::common::ReplyHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fservice_2eproto;
};
// -------------------------------------------------------------------

class UpdatePasswordReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.UpdatePasswordReply) */ {
 public:
  inline UpdatePasswordReply() : UpdatePasswordReply(nullptr) {};
  virtual ~UpdatePasswordReply();

  UpdatePasswordReply(const UpdatePasswordReply& from);
  UpdatePasswordReply(UpdatePasswordReply&& from) noexcept
    : UpdatePasswordReply() {
    *this = ::std::move(from);
  }

  inline UpdatePasswordReply& operator=(const UpdatePasswordReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePasswordReply& operator=(UpdatePasswordReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdatePasswordReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdatePasswordReply* internal_default_instance() {
    return reinterpret_cast<const UpdatePasswordReply*>(
               &_UpdatePasswordReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdatePasswordReply& a, UpdatePasswordReply& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePasswordReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePasswordReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePasswordReply* New() const final {
    return CreateMaybeMessage<UpdatePasswordReply>(nullptr);
  }

  UpdatePasswordReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePasswordReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdatePasswordReply& from);
  void MergeFrom(const UpdatePasswordReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePasswordReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.UpdatePasswordReply";
  }
  protected:
  explicit UpdatePasswordReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_user_5fservice_2eproto);
    return ::descriptor_table_user_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kNeedReloginFieldNumber = 2,
  };
  // .common.ReplyHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::common::ReplyHeader& header() const;
  ::common::ReplyHeader* release_header();
  ::common::ReplyHeader* mutable_header();
  void set_allocated_header(::common::ReplyHeader* header);
  private:
  const ::common::ReplyHeader& _internal_header() const;
  ::common::ReplyHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::common::ReplyHeader* header);
  ::common::ReplyHeader* unsafe_arena_release_header();

  // bool need_relogin = 2;
  void clear_need_relogin();
  bool need_relogin() const;
  void set_need_relogin(bool value);
  private:
  bool _internal_need_relogin() const;
  void _internal_set_need_relogin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:user.UpdatePasswordReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::ReplyHeader* header_;
  bool need_relogin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SignupRequest

// .common.RequestHeader header = 1;
inline bool SignupRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SignupRequest::has_header() const {
  return _internal_has_header();
}
inline const ::common::RequestHeader& SignupRequest::_internal_header() const {
  const ::common::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::RequestHeader*>(
      &::common::_RequestHeader_default_instance_);
}
inline const ::common::RequestHeader& SignupRequest::header() const {
  // @@protoc_insertion_point(field_get:user.SignupRequest.header)
  return _internal_header();
}
inline void SignupRequest::unsafe_arena_set_allocated_header(
    ::common::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.SignupRequest.header)
}
inline ::common::RequestHeader* SignupRequest::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::RequestHeader* SignupRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:user.SignupRequest.header)
  
  ::common::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::RequestHeader* SignupRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::RequestHeader* SignupRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:user.SignupRequest.header)
  return _internal_mutable_header();
}
inline void SignupRequest::set_allocated_header(::common::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:user.SignupRequest.header)
}

// string username = 2;
inline void SignupRequest::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SignupRequest::username() const {
  // @@protoc_insertion_point(field_get:user.SignupRequest.username)
  return _internal_username();
}
inline void SignupRequest::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:user.SignupRequest.username)
}
inline std::string* SignupRequest::mutable_username() {
  // @@protoc_insertion_point(field_mutable:user.SignupRequest.username)
  return _internal_mutable_username();
}
inline const std::string& SignupRequest::_internal_username() const {
  return username_.Get();
}
inline void SignupRequest::_internal_set_username(const std::string& value) {
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SignupRequest::set_username(std::string&& value) {
  
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:user.SignupRequest.username)
}
inline void SignupRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:user.SignupRequest.username)
}
inline void SignupRequest::set_username(const char* value,
    size_t size) {
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:user.SignupRequest.username)
}
inline std::string* SignupRequest::_internal_mutable_username() {
  
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SignupRequest::release_username() {
  // @@protoc_insertion_point(field_release:user.SignupRequest.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SignupRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:user.SignupRequest.username)
}
inline std::string* SignupRequest::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_unsafe_arena_release:user.SignupRequest.username)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return username_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SignupRequest::unsafe_arena_set_allocated_username(
    std::string* username) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (username != nullptr) {
    
  } else {
    
  }
  username_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      username, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.SignupRequest.username)
}

// string password = 3;
inline void SignupRequest::clear_password() {
  password_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SignupRequest::password() const {
  // @@protoc_insertion_point(field_get:user.SignupRequest.password)
  return _internal_password();
}
inline void SignupRequest::set_password(const std::string& value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:user.SignupRequest.password)
}
inline std::string* SignupRequest::mutable_password() {
  // @@protoc_insertion_point(field_mutable:user.SignupRequest.password)
  return _internal_mutable_password();
}
inline const std::string& SignupRequest::_internal_password() const {
  return password_.Get();
}
inline void SignupRequest::_internal_set_password(const std::string& value) {
  
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SignupRequest::set_password(std::string&& value) {
  
  password_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:user.SignupRequest.password)
}
inline void SignupRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:user.SignupRequest.password)
}
inline void SignupRequest::set_password(const char* value,
    size_t size) {
  
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:user.SignupRequest.password)
}
inline std::string* SignupRequest::_internal_mutable_password() {
  
  return password_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SignupRequest::release_password() {
  // @@protoc_insertion_point(field_release:user.SignupRequest.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SignupRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:user.SignupRequest.password)
}
inline std::string* SignupRequest::unsafe_arena_release_password() {
  // @@protoc_insertion_point(field_unsafe_arena_release:user.SignupRequest.password)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return password_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SignupRequest::unsafe_arena_set_allocated_password(
    std::string* password) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (password != nullptr) {
    
  } else {
    
  }
  password_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      password, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.SignupRequest.password)
}

// string role = 4;
inline void SignupRequest::clear_role() {
  role_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SignupRequest::role() const {
  // @@protoc_insertion_point(field_get:user.SignupRequest.role)
  return _internal_role();
}
inline void SignupRequest::set_role(const std::string& value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:user.SignupRequest.role)
}
inline std::string* SignupRequest::mutable_role() {
  // @@protoc_insertion_point(field_mutable:user.SignupRequest.role)
  return _internal_mutable_role();
}
inline const std::string& SignupRequest::_internal_role() const {
  return role_.Get();
}
inline void SignupRequest::_internal_set_role(const std::string& value) {
  
  role_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SignupRequest::set_role(std::string&& value) {
  
  role_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:user.SignupRequest.role)
}
inline void SignupRequest::set_role(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  role_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:user.SignupRequest.role)
}
inline void SignupRequest::set_role(const char* value,
    size_t size) {
  
  role_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:user.SignupRequest.role)
}
inline std::string* SignupRequest::_internal_mutable_role() {
  
  return role_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SignupRequest::release_role() {
  // @@protoc_insertion_point(field_release:user.SignupRequest.role)
  return role_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SignupRequest::set_allocated_role(std::string* role) {
  if (role != nullptr) {
    
  } else {
    
  }
  role_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), role,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:user.SignupRequest.role)
}
inline std::string* SignupRequest::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_unsafe_arena_release:user.SignupRequest.role)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return role_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SignupRequest::unsafe_arena_set_allocated_role(
    std::string* role) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (role != nullptr) {
    
  } else {
    
  }
  role_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      role, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.SignupRequest.role)
}

// -------------------------------------------------------------------

// SignupReply

// .common.ReplyHeader header = 1;
inline bool SignupReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SignupReply::has_header() const {
  return _internal_has_header();
}
inline const ::common::ReplyHeader& SignupReply::_internal_header() const {
  const ::common::ReplyHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::ReplyHeader*>(
      &::common::_ReplyHeader_default_instance_);
}
inline const ::common::ReplyHeader& SignupReply::header() const {
  // @@protoc_insertion_point(field_get:user.SignupReply.header)
  return _internal_header();
}
inline void SignupReply::unsafe_arena_set_allocated_header(
    ::common::ReplyHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.SignupReply.header)
}
inline ::common::ReplyHeader* SignupReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::ReplyHeader* SignupReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:user.SignupReply.header)
  
  ::common::ReplyHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::ReplyHeader* SignupReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ReplyHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::ReplyHeader* SignupReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:user.SignupReply.header)
  return _internal_mutable_header();
}
inline void SignupReply::set_allocated_header(::common::ReplyHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:user.SignupReply.header)
}

// -------------------------------------------------------------------

// LoginRequest

// .common.RequestHeader header = 1;
inline bool LoginRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool LoginRequest::has_header() const {
  return _internal_has_header();
}
inline const ::common::RequestHeader& LoginRequest::_internal_header() const {
  const ::common::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::RequestHeader*>(
      &::common::_RequestHeader_default_instance_);
}
inline const ::common::RequestHeader& LoginRequest::header() const {
  // @@protoc_insertion_point(field_get:user.LoginRequest.header)
  return _internal_header();
}
inline void LoginRequest::unsafe_arena_set_allocated_header(
    ::common::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.LoginRequest.header)
}
inline ::common::RequestHeader* LoginRequest::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::RequestHeader* LoginRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:user.LoginRequest.header)
  
  ::common::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::RequestHeader* LoginRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::RequestHeader* LoginRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:user.LoginRequest.header)
  return _internal_mutable_header();
}
inline void LoginRequest::set_allocated_header(::common::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:user.LoginRequest.header)
}

// string username = 2;
inline void LoginRequest::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LoginRequest::username() const {
  // @@protoc_insertion_point(field_get:user.LoginRequest.username)
  return _internal_username();
}
inline void LoginRequest::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:user.LoginRequest.username)
}
inline std::string* LoginRequest::mutable_username() {
  // @@protoc_insertion_point(field_mutable:user.LoginRequest.username)
  return _internal_mutable_username();
}
inline const std::string& LoginRequest::_internal_username() const {
  return username_.Get();
}
inline void LoginRequest::_internal_set_username(const std::string& value) {
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LoginRequest::set_username(std::string&& value) {
  
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:user.LoginRequest.username)
}
inline void LoginRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:user.LoginRequest.username)
}
inline void LoginRequest::set_username(const char* value,
    size_t size) {
  
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:user.LoginRequest.username)
}
inline std::string* LoginRequest::_internal_mutable_username() {
  
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:user.LoginRequest.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:user.LoginRequest.username)
}
inline std::string* LoginRequest::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_unsafe_arena_release:user.LoginRequest.username)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return username_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LoginRequest::unsafe_arena_set_allocated_username(
    std::string* username) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (username != nullptr) {
    
  } else {
    
  }
  username_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      username, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.LoginRequest.username)
}

// string password = 3;
inline void LoginRequest::clear_password() {
  password_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:user.LoginRequest.password)
  return _internal_password();
}
inline void LoginRequest::set_password(const std::string& value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:user.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() {
  // @@protoc_insertion_point(field_mutable:user.LoginRequest.password)
  return _internal_mutable_password();
}
inline const std::string& LoginRequest::_internal_password() const {
  return password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LoginRequest::set_password(std::string&& value) {
  
  password_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:user.LoginRequest.password)
}
inline void LoginRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:user.LoginRequest.password)
}
inline void LoginRequest::set_password(const char* value,
    size_t size) {
  
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:user.LoginRequest.password)
}
inline std::string* LoginRequest::_internal_mutable_password() {
  
  return password_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:user.LoginRequest.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:user.LoginRequest.password)
}
inline std::string* LoginRequest::unsafe_arena_release_password() {
  // @@protoc_insertion_point(field_unsafe_arena_release:user.LoginRequest.password)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return password_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LoginRequest::unsafe_arena_set_allocated_password(
    std::string* password) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (password != nullptr) {
    
  } else {
    
  }
  password_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      password, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.LoginRequest.password)
}

// -------------------------------------------------------------------

// LoginReply

// .common.ReplyHeader header = 1;
inline bool LoginReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool LoginReply::has_header() const {
  return _internal_has_header();
}
inline const ::common::ReplyHeader& LoginReply::_internal_header() const {
  const ::common::ReplyHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::ReplyHeader*>(
      &::common::_ReplyHeader_default_instance_);
}
inline const ::common::ReplyHeader& LoginReply::header() const {
  // @@protoc_insertion_point(field_get:user.LoginReply.header)
  return _internal_header();
}
inline void LoginReply::unsafe_arena_set_allocated_header(
    ::common::ReplyHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.LoginReply.header)
}
inline ::common::ReplyHeader* LoginReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::ReplyHeader* LoginReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:user.LoginReply.header)
  
  ::common::ReplyHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::ReplyHeader* LoginReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ReplyHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::ReplyHeader* LoginReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:user.LoginReply.header)
  return _internal_mutable_header();
}
inline void LoginReply::set_allocated_header(::common::ReplyHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:user.LoginReply.header)
}

// int64 user_id = 2;
inline void LoginReply::clear_user_id() {
  user_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginReply::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginReply::user_id() const {
  // @@protoc_insertion_point(field_get:user.LoginReply.user_id)
  return _internal_user_id();
}
inline void LoginReply::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  user_id_ = value;
}
inline void LoginReply::set_user_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:user.LoginReply.user_id)
}

// string auth_key = 3;
inline void LoginReply::clear_auth_key() {
  auth_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LoginReply::auth_key() const {
  // @@protoc_insertion_point(field_get:user.LoginReply.auth_key)
  return _internal_auth_key();
}
inline void LoginReply::set_auth_key(const std::string& value) {
  _internal_set_auth_key(value);
  // @@protoc_insertion_point(field_set:user.LoginReply.auth_key)
}
inline std::string* LoginReply::mutable_auth_key() {
  // @@protoc_insertion_point(field_mutable:user.LoginReply.auth_key)
  return _internal_mutable_auth_key();
}
inline const std::string& LoginReply::_internal_auth_key() const {
  return auth_key_.Get();
}
inline void LoginReply::_internal_set_auth_key(const std::string& value) {
  
  auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LoginReply::set_auth_key(std::string&& value) {
  
  auth_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:user.LoginReply.auth_key)
}
inline void LoginReply::set_auth_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:user.LoginReply.auth_key)
}
inline void LoginReply::set_auth_key(const char* value,
    size_t size) {
  
  auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:user.LoginReply.auth_key)
}
inline std::string* LoginReply::_internal_mutable_auth_key() {
  
  return auth_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LoginReply::release_auth_key() {
  // @@protoc_insertion_point(field_release:user.LoginReply.auth_key)
  return auth_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginReply::set_allocated_auth_key(std::string* auth_key) {
  if (auth_key != nullptr) {
    
  } else {
    
  }
  auth_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:user.LoginReply.auth_key)
}
inline std::string* LoginReply::unsafe_arena_release_auth_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:user.LoginReply.auth_key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return auth_key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LoginReply::unsafe_arena_set_allocated_auth_key(
    std::string* auth_key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (auth_key != nullptr) {
    
  } else {
    
  }
  auth_key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      auth_key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.LoginReply.auth_key)
}

// -------------------------------------------------------------------

// LogoutRequest

// .common.RequestHeader header = 1;
inline bool LogoutRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool LogoutRequest::has_header() const {
  return _internal_has_header();
}
inline const ::common::RequestHeader& LogoutRequest::_internal_header() const {
  const ::common::RequestHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::RequestHeader*>(
      &::common::_RequestHeader_default_instance_);
}
inline const ::common::RequestHeader& LogoutRequest::header() const {
  // @@protoc_insertion_point(field_get:user.LogoutRequest.header)
  return _internal_header();
}
inline void LogoutRequest::unsafe_arena_set_allocated_header(
    ::common::RequestHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.LogoutRequest.header)
}
inline ::common::RequestHeader* LogoutRequest::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::RequestHeader* LogoutRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:user.LogoutRequest.header)
  
  ::common::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::RequestHeader* LogoutRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::RequestHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::RequestHeader* LogoutRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:user.LogoutRequest.header)
  return _internal_mutable_header();
}
inline void LogoutRequest::set_allocated_header(::common::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:user.LogoutRequest.header)
}

// -------------------------------------------------------------------

// LogoutReply

// .common.ReplyHeader header = 1;
inline bool LogoutReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool LogoutReply::has_header() const {
  return _internal_has_header();
}
inline const ::common::ReplyHeader& LogoutReply::_internal_header() const {
  const ::common::ReplyHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::ReplyHeader*>(
      &::common::_ReplyHeader_default_instance_);
}
inline const ::common::ReplyHeader& LogoutReply::header() const {
  // @@protoc_insertion_point(field_get:user.LogoutReply.header)
  return _internal_header();
}
inline void LogoutReply::unsafe_arena_set_allocated_header(
    ::common::ReplyHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.LogoutReply.header)
}
inline ::common::ReplyHeader* LogoutReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::ReplyHeader* LogoutReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:user.LogoutReply.header)
  
  ::common::ReplyHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::ReplyHeader* LogoutReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ReplyHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::ReplyHeader* LogoutReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:user.LogoutReply.header)
  return _internal_mutable_header();
}
inline void LogoutReply::set_allocated_header(::common::ReplyHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:user.LogoutReply.header)
}

// -------------------------------------------------------------------

// UpdatePasswordRequest

// .common.ReplyHeader header = 1;
inline bool UpdatePasswordRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool UpdatePasswordRequest::has_header() const {
  return _internal_has_header();
}
inline const ::common::ReplyHeader& UpdatePasswordRequest::_internal_header() const {
  const ::common::ReplyHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::ReplyHeader*>(
      &::common::_ReplyHeader_default_instance_);
}
inline const ::common::ReplyHeader& UpdatePasswordRequest::header() const {
  // @@protoc_insertion_point(field_get:user.UpdatePasswordRequest.header)
  return _internal_header();
}
inline void UpdatePasswordRequest::unsafe_arena_set_allocated_header(
    ::common::ReplyHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.UpdatePasswordRequest.header)
}
inline ::common::ReplyHeader* UpdatePasswordRequest::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::ReplyHeader* UpdatePasswordRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:user.UpdatePasswordRequest.header)
  
  ::common::ReplyHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::ReplyHeader* UpdatePasswordRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ReplyHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::ReplyHeader* UpdatePasswordRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:user.UpdatePasswordRequest.header)
  return _internal_mutable_header();
}
inline void UpdatePasswordRequest::set_allocated_header(::common::ReplyHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:user.UpdatePasswordRequest.header)
}

// string password = 2;
inline void UpdatePasswordRequest::clear_password() {
  password_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UpdatePasswordRequest::password() const {
  // @@protoc_insertion_point(field_get:user.UpdatePasswordRequest.password)
  return _internal_password();
}
inline void UpdatePasswordRequest::set_password(const std::string& value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:user.UpdatePasswordRequest.password)
}
inline std::string* UpdatePasswordRequest::mutable_password() {
  // @@protoc_insertion_point(field_mutable:user.UpdatePasswordRequest.password)
  return _internal_mutable_password();
}
inline const std::string& UpdatePasswordRequest::_internal_password() const {
  return password_.Get();
}
inline void UpdatePasswordRequest::_internal_set_password(const std::string& value) {
  
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UpdatePasswordRequest::set_password(std::string&& value) {
  
  password_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:user.UpdatePasswordRequest.password)
}
inline void UpdatePasswordRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:user.UpdatePasswordRequest.password)
}
inline void UpdatePasswordRequest::set_password(const char* value,
    size_t size) {
  
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:user.UpdatePasswordRequest.password)
}
inline std::string* UpdatePasswordRequest::_internal_mutable_password() {
  
  return password_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UpdatePasswordRequest::release_password() {
  // @@protoc_insertion_point(field_release:user.UpdatePasswordRequest.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdatePasswordRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:user.UpdatePasswordRequest.password)
}
inline std::string* UpdatePasswordRequest::unsafe_arena_release_password() {
  // @@protoc_insertion_point(field_unsafe_arena_release:user.UpdatePasswordRequest.password)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return password_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UpdatePasswordRequest::unsafe_arena_set_allocated_password(
    std::string* password) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (password != nullptr) {
    
  } else {
    
  }
  password_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      password, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.UpdatePasswordRequest.password)
}

// -------------------------------------------------------------------

// UpdatePasswordReply

// .common.ReplyHeader header = 1;
inline bool UpdatePasswordReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool UpdatePasswordReply::has_header() const {
  return _internal_has_header();
}
inline const ::common::ReplyHeader& UpdatePasswordReply::_internal_header() const {
  const ::common::ReplyHeader* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::common::ReplyHeader*>(
      &::common::_ReplyHeader_default_instance_);
}
inline const ::common::ReplyHeader& UpdatePasswordReply::header() const {
  // @@protoc_insertion_point(field_get:user.UpdatePasswordReply.header)
  return _internal_header();
}
inline void UpdatePasswordReply::unsafe_arena_set_allocated_header(
    ::common::ReplyHeader* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.UpdatePasswordReply.header)
}
inline ::common::ReplyHeader* UpdatePasswordReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::common::ReplyHeader* UpdatePasswordReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:user.UpdatePasswordReply.header)
  
  ::common::ReplyHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::common::ReplyHeader* UpdatePasswordReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ReplyHeader>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::common::ReplyHeader* UpdatePasswordReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:user.UpdatePasswordReply.header)
  return _internal_mutable_header();
}
inline void UpdatePasswordReply::set_allocated_header(::common::ReplyHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header)->GetArena();
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:user.UpdatePasswordReply.header)
}

// bool need_relogin = 2;
inline void UpdatePasswordReply::clear_need_relogin() {
  need_relogin_ = false;
}
inline bool UpdatePasswordReply::_internal_need_relogin() const {
  return need_relogin_;
}
inline bool UpdatePasswordReply::need_relogin() const {
  // @@protoc_insertion_point(field_get:user.UpdatePasswordReply.need_relogin)
  return _internal_need_relogin();
}
inline void UpdatePasswordReply::_internal_set_need_relogin(bool value) {
  
  need_relogin_ = value;
}
inline void UpdatePasswordReply::set_need_relogin(bool value) {
  _internal_set_need_relogin(value);
  // @@protoc_insertion_point(field_set:user.UpdatePasswordReply.need_relogin)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace user

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_user_5fservice_2eproto
